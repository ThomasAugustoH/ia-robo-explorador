O agente robótico implementado segue uma arquitetura de agente reativo simples, baseado em um comportamento determinístico de movimentação e rotação. A classe Robot encapsula toda a lógica comportamental, iniciando com uma posição aleatória no grid e uma direção inicial (direção 1, que corresponde ao movimento para cima). O sistema de direções utiliza uma codificação numérica: 1 para norte (y+1), 2 para leste (x+1), 3 para sul (y-1) e 4 para oeste (x-1).

A estratégia de movimentação é baseada em dois comportamentos principais: movimento linear até encontrar uma barreira e rotação quando o movimento não é mais possível. O método get_movement_based_on_direction() calcula a próxima posição baseada na direção atual, enquanto can_move_forward() verifica se o movimento é válido dentro dos limites do grid. Quando o robô não consegue mais se mover na direção atual, ele executa uma rotação de 90 graus no sentido horário através do método rotate(), incrementando o valor da direção. Este processo continua até que todas as quatro direções tenham sido testadas (direction < 5).

O sistema demonstra um comportamento previsível e consistente, com o robô sempre conseguindo "tocar" todas as quatro paredes do grid em uma única execução. A métrica principal de sucesso é a capacidade do agente de explorar completamente o perímetro do ambiente, o que é garantido pela lógica de rotação sequencial. O número de movimentos varia dependendo da posição inicial, sendo máximo quando o robô inicia no centro (aproximadamente 36 movimentos) e mínimo quando inicia próximo a uma das bordas (chegando a 18 movimentos).

A eficiência do algoritmo pode ser medida pela razão entre a distância total percorrida e a menor distância possível para atingir todas as bordas. Embora não seja otimizado para eficiência de caminho, o algoritmo garante 100% de cobertura das bordas em tempo finito. O comportamento determinístico após a escolha da posição inicial permite prever exatamente a trajetória que será seguida, facilitando análises de desempenho e depuração.