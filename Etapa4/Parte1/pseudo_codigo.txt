Programa principal:
    path, cost <- shortest_path_and_cost(G, source, target)
    Se path for vazio:
        Imprimir "Não existe caminho entre source e target"
    Senão:
        Imprimir "Caminho mais curto:", path
        Imprimir "Custo:", cost

Função shortest_path_and_cost(G, source, target):
    path <- dijkstra_shortest_path(G, source, target)
    Se path for nulo:
        Retornar vazio, infinito
    cost <- 0
    Para i de 0 até comprimento(path) - 2:
        u <- path[i]
        v <- path[i + 1]
        cost <- cost + peso_da_aresta(G, u, v)
    Retornar path, cost

Função dijkstra_shortest_path(G, source, target):
    Para cada vértice v em G:
        dist[v] <- +infinito
        prev[v] <- indefinido
    dist[source] <- 0
    Q <- conjunto de todos os vértices (fila de prioridade por dist)

    Enquanto Q não vazio:
        u <- extrair vértice em Q com menor dist[u]
        Se u == target:
            Interromper  # caminho mais curto encontrado
        Para cada vizinho v de u:
            alt <- dist[u] + peso_da_aresta(G, u, v)
            Se alt < dist[v]:
                dist[v] <- alt
                prev[v] <- u
                atualizar_prioridade_em_Q(v, dist[v])

    Se dist[target] == +infinito:
        Retornar nulo  # não existe caminho
    # Reconstruir caminho de source até target
    path <- lista vazia
    u <- target
    Enquanto u indefinido:
        inserir u no início de path
        u <- prev[u]
    Retornar path
