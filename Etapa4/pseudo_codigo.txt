caminho_mais_curto, custo = achar_caminho_mais_curto_e_peso(grafo, origem, destino)

para i de 0 até caminho_mais_curto.comprimento - 2:
    u <- caminho_mais_curto[i]
    v <- caminho_mais_curto[i+1]
    imprimir("aresta:", u, "->", v, "peso:", peso(u,v))
fim para

imprimir("Custo total:", custo)


achar_caminho_mais_curto_e_peso(grafo, origem, destino)
    d[], pi[] <- DIJKSTRA(grafo, origem)

    if pi[destino] == NIL and destino != origem
        então
            retorna ([], ∞)   # sem caminho
    fim if

    caminho_mais_curto <- CONSTRUIR_CAMINHO(pi, origem, destino)

    custo <- 0
    para i de 0 até caminho_mais_curto.comprimento - 2:
        u <- caminho_mais_curto[i]
        v <- caminho_mais_curto[i+1]
        custo <- custo + peso(u, v)
    fim para

    retorna caminho_mais_curto, custo
fim achar_caminho_mais_curto_e_peso


CONSTRUIR_CAMINHO(pi, origem, v)
    caminho <- lista vazia
    atual <- v
    enquanto atual != NIL:
        inserir atual no início de caminho
        if atual == origem:
            break
        atual <- pi[atual]
    fim enquanto

    if caminho[0] != origem:
        retorna []   # sem caminho válido
    fim if

    retorna caminho
fim CONSTRUIR_CAMINHO


DIJKSTRA(G, s)
    INITIALIZE-SINGLE-SOURCE(G, s)
    S <- ∅
    Q <- V[G]   # fila (min-heap) por d[v]
    enquanto Q != ∅:
        u <- EXTRACT-MIN(Q)
        S <- S ∪ {u}
        para cada v ∈ Adj[u]:
            RELAX(u, v, w)   # w(u,v) é o peso da aresta
        fim para
    fim enquanto
    retorna d, pi
fim DIJKSTRA


RELAX(u, v, w)
    if d[v] > d[u] + w(u, v)
        então
            d[v] <- d[u] + w(u, v)
            pi[v] <- u
            # se estiver usando um heap com chaves, atualizar a chave de v
    fim if
fim RELAX


INITIALIZE-SINGLE-SOURCE(G, s)
    para cada vértice v em V[G]:
        d[v] <- ∞
        pi[v] <- NIL
    fim para
    d[s] <- 0
fim INITIALIZE-SINGLE-SOURCE
